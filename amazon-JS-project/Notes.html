<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>

    /*
    Main Idea of J:
    1. Save the data
    2. Generate the HTML
    3. Make it interactive
    
    const products= [];
    Here we used variable prdodcuts to save the information about products and we are using objects to store various information about product such as image, description, rating etc.,
    */

    /* We initiated  a variable called productsHTML to combine html together and to put it on web page we are using DOM */

    /* When we click on add to cart button then that product should go to cart page for that we created cart.js in data folder
    
    How do we knw which product to add?
     
    Data attribte:
    -is just anoother HTML attribute
    - allows us to attach any information to an element
Syntax:
      In Html after giving class use "data-anyname="${productname}""  
  Syntax rules for data attribute:
  - its just an HTML attribute
  - data attribute should start with data- and name on left and value on right -- see syntax above
    
    */

    /* dataset property gives us all the data attributes attached to the button*/

    /* Here we pushed into cart variable in cart.js. Here we sucessfully added products into cart. But if we are clicking on the same add to cart button it showing quantty 1 insted of 2 for example: if we added basketfall into cart it shows quantity to 1 but agan if we added basket ball it again shows quantity 1 but in different array. To overcome this:
    Steps: 1. Check if the product is already in the cart
    2. If it is in the cart, increase the qunatity.
    3. It its not in the cart add it to the cart */

    /* Making cart button(on top right corner interactive):

    Steps:
     1. Calculate the quanity
     2. Put the quantity on the page.

     Cart is the array of objects(in out code), so to calcualte the quantity we have to loop through to the array and add the quantity together

      We learnt:
      1. Amazon project - started
      2. Set up and git
      3. Main idea of JS: Save the data
                          Generate the HTML
                          Make it interactive
      4. Created list of products
      5. Made the "Add to cart " button interactive
      6. Made the cart quantity interactive                      


    */

  Modules


  /*
    So we linked js to html in amazon.html like this:
        <script src="data/products.js"></script>
        <script src="scripts/amazon.js"></script>

    This is combining all the files togeher into 1 big file and run all the code. 

    But the BIG problem is naming conflicts: For example: in cart.js we have a variable called cart. This means we cant use cart variable in any other files. If declared, we will get a error saying 'cart' has already been declared. This is called Naming conflict: two variables with same name.

    How to solve this? Modules.

    cart -> cart.js
    cart -> amazon.js

    No conflicts

    Ho to create modules? 

    To create a module we just have to delete <script src="data/cart.js"></script>

    If we use a script tag:         <script src="data/cart.js"></script>:
    1. this run all the code inside cart.js
    2. this code create a cart variable
    3. this will cause a naming conflict.
    
    So by removing the script tag we no longer running the code i cart.js so we are no longer creating cart variable and no longer creating naming conflict.

    To create a module:
      1. Create a file and write our code nside that file
      2. Dont load the file with <script> tag
      By doing this any variables we create inside the file will be contained inside the file. So wont cause naming conflict. 

      Problem here:After removing <script src="data/cart.js"></script> we dont load cart variable which is inside  <script src="data/cart.js"></script> but we used in amazon.js so we will get an error saying cart doesnt exist. To solve this: continute below

      How to get a variable out of a file? 
      1. Add type="module" attribute
      2. Export
      3. Import

      type="module" is a html attribute which lets a file get variables out of other files. 
      ex:     <script type="module" src="scripts/amazon.js"></script>

      export: just include export before declaring variable
      ex: export const cart= []; in cart.js 

      import: import {cart} from '../data/cart.js'
      here cart is varaible and ../ to exit from scripts folder and then go to the file where cart is located

      1. We have to put all th imports at the top of the file
      2. We need to use live server inorder to work modules. Modules wont work if we open html file directly(like going to file and open .html file manually)

      Benifits of modules: 
        1. Avoids naming conflicts

       2. Renaming
       
       Now: 
        import {cart} from '../data/cart.js'
        const cart = [];

        This again causes naming conflict to overcome this: rename cart 

        import {cart as myCart} from '../data/cart.js'
        const cart = [];

        Modules has lot of feature to overcome naming conflicts

        3. No need to worry for ordering on files
        Module are better way to organise our code especially in better projects

        We should atleast link/connect/load one .js file to html using <script></script>. And that one .js file will import other files
        and this one file is called Entry Point. 

        If theres a lot of code inside a function then split it to a function call it in the function where the code is needed
        12:466:30 If not understood.

        Best Practice: Group related code together int its own file.
        Explanation: Earler the function addToCart is in amazon.js but it is handling the cart. So it is better to keep that function in cart.js. And we have to use modules for this to import and export. and updateCartQuantity() function handles updating the webpage rather than managing the cart so better to keep in amazon.js 

        Another syntax of modules:

        import * as cartModule from '../data/cart.js'
        
        cartModule.cart
        cartModule.addToCart('id');


        It imports everything from a file and groups it together inside as cartModule object.



        Cart option on right top:

          It uses a link element. Link element has feature called href.
          <a href="https://youtube.com">...</a>
          <a href="checkout.html">...</a>
          If we click on this lnk element it will redirect to another page which is specified on href.

  */

  /*

  checkout.js page:

  Main Idea of JS:
  1. Save the data: 
  2. Generate the HTML
  3. Make it interactive


  Normalizing the data, a commontechnique in software field

  */


  

  /* 
  import {formatCurrency} from './utils/money.js';
        Here, single dot means, current folder
  
  */

  /* 
          Problem: After generating HTML in JS, we faced a problem: If we selects delevert date for prodct 1 then automatically it was unchecking the delivery date for prouct 2. Here, it only ables to select delivery date for only one product.

          Solution: Radio selector: <input type="radio" name="name1">
            If a set of radio selectors have the same name then we can only select only one of them.
            same name = we can only select one of them.
            Example: In the choose a delivery option: we have dayes and days, uesday, wednesday and monday. If these theree has same name, then we can only choose one option.

            // For tues, wed ad monday for product 1
            <input type="radio" name = "name1">
            <input type="radio" name = "name1">
            <input type="radio" name = "name1">

            So if product 1 has differnt radio selector name  and product2 has different radio selector name then it will work

            // For tues, wed ad monday for product 2
            <input type="radio" name = "name2">
            <input type="radio" name = "name2">
            <input type="radio" name = "name2">
            So the soltin is giving product id. because of its uniqueness

  */

  /*
        Delete option in checkout page. If we click delete option, product should remove from the cart.
        How?
        Step-1. Remove the product from the Cart
        Step-2. Update the HTML
        Start: 
        First lets add event listeners and select all the delete options using document.queryselectorAll and loop through it and for each delete button we should add event listener.

        Again back to step-1:
          How do we know which product to remove?
            Just like add to cart we have to attach the product id using data attribute(data-anyname)
            Like this: 
            /*
            <button class="add-to-cart-button button-primary js-add-to-cart"
            data-product-id="${product.id}">
             Add to Cart
             */

          How do we remove the productId from the cart?
            To do this we have a create a functon inside cart.js because cart.js has the code related to cart page which help us to organize our code


          Step 2: Update the HTML
          How?
          Step-a: Use the DOM t get the element to remove
          Step-b: Use .remove() method


          How to know which element to delete?
            Solution: Add a special class which has product Id - js-cart-item-container-${matchingProduct.id}

            Now use dom to get this class


        






  */

  /*
          In this Lesson: 
           Modules = better way to organize the code
           Created a check out page
           HTML link element and radio selectors
           Made delete link interactive
           Saved the cart in local Stroage
  */


  /* 
        Lesson - 15: External Libraries, MVC, Finih the checkout page :

        External Library: Code that is outside our project
        
        Developers write JS code and put it on the internet and we can load thier code from the internet  into our project and use it and we call this code externa library.
        Example: https://unpkg.com/supersimpledev@1.0.1/hello.js
        We can use this code
        <script src="https://unpkg.com/supersimpledev@1.0.1/hello.js" ></script>
        Always use/describe/mention exteral libraries at first
        
        Why we use external libraries:
          Let us share code
          Instead of writing all the code ourself we can use the code wroteby other developers which helps us to,
            save time
            avoid duplictaing work

        Lets use some other large external libraries:
          As you can see in our project, Free deivery takes 11 days to deliver, 4.99 takes 5 days and 9.99 takes 1 day to deliver
        To get these dates:
          1. Get todays date
          2. Do calculations(Add x days)
          3. Display date in easy to read format

        We can use external library here as it will take lot of time.
        
        There's a external library called DayJS. 
          First load DayJS

        External libraries have documentation so better to visit once.
        today.add(7, 'days'); This add method takes two parameters, first one is numbr of time to add and second one is what to add(ex: days). The above today.add(7, 'days'); add 7 days to the todays date.

        and dayjs() has one more method: dayjs().format(), which helps to print in easy to read format. 
        
        deliveryDate.format('dddd, MMMM D');


        Due to naming conflicts it better not uto load external libraries using script tag. So better to use JS Modules.

        To use external libraries and JS Modules together, we should use ESM  version
        ESM Version: EcmaScript Module (EcmaScript = JavaScript)
        A version that works with JS Modules.

        Default export: 
          Another way of exporting
          We can use it when we only want to export 1 thing
          
        For some external libraries we still have to use script tag.



        Now, if choose delivery option for 3 days then 4.99 dollars dhould be added tpo cart, and viceversa. For that, 
        1. Delivery time
        2. Price

        Our cart: cart = [{
          productId: 'uywjdgycwejsf';
          quantity: 2,
        }, {
            productId: 'ewfsvcyeukfsds';
            quantity: 1
        }]

        We can add delivertTime and deliveryPrice to the cart like this: 
        Our cart: cart = [{
          productId: 'uywjdgycwejsf';
          quantity: 2,
          deliveryTime: '3 days',
          deliveryPrice: 499
        
        }, {
            productId: 'ewfsvcyeukfsds';
            quantity: 1,
            deliveryTime: '3 days',
            deliveryPrice: 499
        }]
        But this will make duplicate 

        So we are saving delivery Options separtely
        deliveryOptions = [{
          id: 1,
          deliveryTime: '7 days',
          deliveryPrice: 0
        }, {
          id: 2,
          deliveryTime: '3 days',
          deliveryPrice: 499
        }]

        and just save id in cart:

        cart = [{
          productId: 'uywjdgycwejsf';
          quantity: 2,
          deliveryOptionId: '2'
        
        }, {
            productId: 'ewfsvcyeukfsds';
            quantity: 1,
            deliveryOptionId: '2'
        }]

        This technique is called Normalizing the data.

        Firt lets create the data for delivery options.

        For new poducts(after add to cart) we are giving default deivery Id as 1(free shipping).


        We might have a cart saved in local storage so to add delievry option id to local storage as well. So we have to delete the cart in local storage and we can use the default values
        in console type: localStorage.removeItem('cart').

       localStorage.clear() typethis inthe chrome console if facing any errors even code is correct it might be due to bad storage in local storage.

       If we got errors likes object object, then check your code, always JSON.stringify() before saving to localStorage



       iF price is 0 then display free
       If price is not 0 then display price

*/

/*
A function can call/re run itself and it is called recusrion.


To update the data/page we used a technique:
  1. Update the data
  2. Regenerate all the HTML
  and this technique is called MVC.
Model View Control: POPULAR TECHNIQUE IN SOTWARE ENGINEERING
MVC split our code into 3 parts
        1. Model = saves and manages the data(all the code in data folder is model becuase it saves and manages the data)
        2. View = take sthe data and displays on the page(checkout.js is view because it takes the data and generates the HTML)
        3. Controller = runs some code when we interacted with the page(bottom of checkout.js(eventListeners))4

      They thre interact with each othr in a loop.

      First, we use model to generate view, then we interactive with view to run controller then the controller will update the model and finally we use the updated model to regenrate the view. wE USED THIS IN our project
      MVC=Makes sure the page always matches the data
      MVC is a design pattern.
      Many JS frameworks  are on MVC

*/

/*
In this lesson, 
        1. external libraries = code outside of out project
        2. DayJS external library
        3. EXTERNAL LIBRARIES + JS modules, default export
        4. Created the deivery section
        5. MVC -  Model View Control
        6. created the payment section

*/


/*
Errors:
        If you get an error but code looks good, then type localStorage.clear();
        this is because you may have some bad data saved in local storage and refresh the page.

        If you see the error [object object] it is due to you saved something directly to the localstorage.
        to avoid this 1. Check yor code, always JSON.Stringify() before saving to localStorage.
                      2. localStorage.clear()
                      3. Refresh the page
*/

/*
                                TESTING
      Esiest way to test:
        Open the website and try out the code. This is called Manual TESTING
          Disadvanatges of manual testing:
            1. Hard to test evry situation and Takes lot of time 
            2. Hard to re-test
            
          To solve this: Automated Testing: using code to test code.

          How many test cases should we hvae to write?
            We have 2 types of test cases.
                1. Basic test cases = tests if the code is working or not
                2. Edge cases = test with values that are tricky
              Give each test case a name
            
            Group related tests together
            Group of related tests = test suite;

*/


/*

                                                  TESTING FRAMEWORKS

Testing Frameworks: External library that helps us write tests earlier
Jasmine Testing Framework: Almost testing frameworks are similar.
Other testing frameworks: Jest(For ReactJS), MochaJS.


In Jasmine, Spec = test. So SpecRunner(now tests.html) means TestRunner.

In tests.html:
          <!-- include source files here... -->
  <script src="src/Player.js"></script>
  <script src="src/Song.js"></script>

  These are files which we are gng to test. EX: Money.js

  <!-- include spec files here... -->
  <script src="spec/SpecHelper.js"></script>
  <script src="spec/PlayerSpec.js"></script>
  These are the testing files ex: tests.html in utils folder inside tests folder.

  As discussed earlier, testing frameworkd do:
        1. create test suite
        2. create tests
        3. compare values and display results
  Testing framewroks: an external library that helps us write tests easier

  In Jasmine to write a test suite, we have to use describe() function.
  Has 2 parameters:
  1. name it in a string, 
  2. function to add tests.

  After this we have to create a tests:
   To do that we should use it(description, testFunction, timeout);
   description = name in string.

   In jasmine, instead of creating if statements and displaying results ouself, jasmine provides another function to do all fof it and that function is called expect();
   expect() lets us compare our value to another value.
   ex: expect(formatCurrency(2095))
   To compare expect(formatCurrency(2095)), expect gives us anbject and this object have many methods to compare. One methos is .toEqual.
   expect(formatCurrency(2095)).toEqual('20.95');

   Jasmine is just like english.
   We can also use describe() inside a describe().

   Test a differet functions using jasmine:
   Features of testing framework:

   Best Practice:
        Test each condition of an if-statement an it is called test coverage.
        Test coverage = how much of the code is being tested.
        Tryt to maximize test coverage.
        Example: in cart.js, in addToCart function we have to test if statement first(whether the product is already in the cart) and then else statement(whether the product is not in the cart).

        Here, we cant use expect() because we cant compare here because addToCart wont return anything to compare.

        Here, cart takes input from local Sroage which means if cart is empty, it has 2 defaut values.

        Flaky test =  test that sometimes passes and sometimes fails.
        
        Mocks= lets us replace a method with a fake version anything we want.

        We can create a mock using spyOn.
        Takes two parameters: 1. object we want to mock 
                              2. a method in string we want t mock
                              
        So it will replace localStorage.getItem with a fake version. We can make this fake version to anyting we want.
         To do that, spyOn gives us an object and this object has an property to Use
         spyOn(localStorage, 'getItem').and.callFake();
         here and is also a object and callFake is a method.
         Here we have to give .cakeFake a function and this function overrides original getItem with whatever inside the function. So we are making getItem empty array.
         
         Local strorage only supports string so we need to return in string.
         
         Here we are still failing i tests
         Reasons: here, we already load cart from localStrage in the first line of the code using import, and then we are mocking. order of the code matters.

         One way to solve the problem, once we mock the localStorage, we should reload the cart. So re run the code.
         How?
         use a function loadFromStorage() and psh the previous code manually.

         in cart.js we ar saving the cart into localStorage using localStorage.setItem. We dont want our test code to modify localStorage and effecting our real code
         So lets mock setItem as well. 16:40:00.


         Here order of the code matters, first we have to  mock localStorage.setItem first and then we call add to cart so no setItem replaces with a fake version and this will no longer saved to local Storage.


         spyOn() has one more usefull feature. It records every time when a method is used.

         For example: what if we want to make sure that addToCart saved the cart into localStorage in the end.
         In out tests setItem is mocked so we cant really checked whats inside localStrogae. Instead we can just check addToCart call setItem at some point.
        To do that: 1st parameter is method we mocked
         expect(localStorage.setItem).toHaveBeenCalledTimes;
         This tells how many times localStorage.setItem called

         A mock only lasts for one test.


         Creating more complicated testing:

         Unit Testing: Testing one piece of the code.

        Testing whole page or some part of the page is called Integration Test.

        Integration Test =  test many unites/pieces of code working together.

        In integration test, we have 2 things to test:
          1. How the page looks
          2. How the page behaves

        So, In orderSummaryTesr.js we are mocking localStorage age because by default orderSummary.js load cart from localStorage

        Lets see if we click on delete button the product is gettting delete or not.

        Hooks: Lets us run some code for each Test

        Example: Wecan share a same piece of code for tests using hooks.

        beforeEach() - Before each of our tests beforeEach() functions runs.
        Helps to duplication.

        Hooks in Jasmine:
          beforeEach() - runs code before each Test
          afterEach() -  runs code after each Test - usefull for cleanup code - just like removing html after tests in our orderSummaryTest.js tests
          beforeAll() - runs code before all tests
          afterAll() -  runs code after all tests


          In this lesson:
            1. Manual and automated tests
            2. Test cases and test suites
            3. Testing frameworks =  helps us writetests easier
            4. Mock and spy on methods
            5. Test web pages using integration tests
            6. Hooks


*/

/*

        Object Oriented Programming - Oop
          
          - Another style of Programming/Another way we write our code
          - Organizing our code into objects


          Procedural Programming 
          Procedure: A set of step ny step instructions
                    This is basically a function
                  
                      In procudeure programming, we organize our code into separate function
                      O the other hand, in oop, we organize our code into objects


                      export let cart; is same as export let cart=undefined;


                      Inside an object we cant use the words export and let.
                      We cant use the export inside the object so we have to convert as property and value.
                      Always use regular function inside not arrow functions.
                      
                      Function inside an object = method

                      Shortcut for methods;
                      Shorthand method syntax:  Instead of writng loadFromStorage: function() we can just write loadFromStorage().
                      loadFromStorage: function() same as  loadFromStorage().

                      Here, cart.cartItems: cart is a object. If we change the object name we will get some errors so we will use this. 
                      Example: this.cartItems.


                  Why OOP?
                    Tries to represent the real world
                    Easy to create multiple objects - Ex: We simplly copied cart object and make a new business cart(check cart-oop.js).

          We can use a function to create multiple objects:
          In OOP use PascalCase for things that generate objects
          Instead of copy paste to create objects, we can use functions and call it whenver we need. 






*/

          An Even better way to generate objects -> Class

          A class is  specifically designed for objects

          Class = object generator

          Benifits of classes: 
            Classes has extra features of object oriented proramming.

            Constructor: Lets us run setup code

            More details on constructor:
              Has to be named "constructor"
              Should not return anything.

          cartItems=uncefined;
          In clases we can wr=rite this as cartItems;


          Private properties and methods.
          Private properties :

          add number sign or #.
          Private properties can only be used inside a class and cant be used outside the class.

          Aproperty with # infront is public property and can be used anywhere.


          In console, field = property

          Private Methods :
          add number sign or #.
          






  </script>
</body>
</html>